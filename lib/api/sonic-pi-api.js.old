'use babel';
let SonicPiApi;

const {CompositeDisposable} = require('atom');
const electron              = require('electron').remote;

const os                    = require('os');
const process               = require('process');
const fs                    = require('fs');
const path                  = require('path');
const child_process         = require('child_process');
const net                   = require('net');

const uuid                  = require('uuid')
const osc                   = require('node-osc');

// const logger = require('../utils/logger.js');
const proc_utils = require('../utils/proc_utils.js')

const State = {
  Start: 0,
  Initializing: 1,
  Invalid: 2,
  Created: 3
};

function sleep(ms) {
   return new Promise(resolve => setTimeout(resolve, ms));
}

export default class SonicPiAPI {
  constructor(root_path) {
    this.use_udp = false;
    this.m_paths =  {
        RootPath: "", // Sonic Pi Application root
        RubyPath: "", // Path to ruby executable
        RubyServerPath: "", // Path to the ruby server script
        PortDiscoveryPath: "", // Path to the port discovery script
        FetchUrlPath: "", // Path to the fetch url script
        SamplePath: "", // Path to the samples folder
        UserPath: "",
        ServerErrorLogPath: "",
        ServerOutputLogPath: "",
        ProcessLogPath: "",
        SCSynthLogPath: "",
        InitScriptPath: "",
        ExitScriptPath: "",
        GUILogPath: "",
        TaskRegisterPath: ""
    }
    this.m_ports = {}
    this.m_guid = "";
    this.init(root_path);
 }
//
//
// using TimePoint = std::chrono::time_point<std::chrono::high_resolution_clock>;
//
// struct CueInfo
// {
//     std::string time;
//     std::string address;
//     int id;
//     std::string args;
//     uint64_t index;
//     TimePoint arrivalTime;
// };
//
// // This is the processed audio data from the thread
// struct ProcessedAudio
// {
//     std::vector<float> m_spectrum[2];
//     std::vector<float> m_spectrumQuantized[2];
//     std::vector<float> m_samples[2];
//     std::vector<float> m_monoSamples;
// };
//
// enum class MessageType
// {
//     StartupError,
//     RuntimeError,
//     SyntaxError,
//     Message,
//     Info,
//     InfoText,
//     Muti
// };
//
// struct MessageData
// {
//     std::string text;
//     int style = 0;
// };
//
// struct MessageInfo : MessageData
// {
//     MessageType type;
//     int jobId = 0;
//     std::string threadName;
//     std::string runtime;
//     std::string backtrace;
//     int line = 0;
//     std::string errorLineString;
//     std::string lineNumString;
//
//     std::vector<MessageData> multi;
// };
//
// enum class MidiType
// {
//     Out,
//     In
// };
//
// struct MidiInfo
// {
//     MidiType type;
//     std::string portInfo;
// };
//
// enum class StatusType
// {
//     Ack,
//     AllComplete,
//     Exited
// };
//
// struct StatusInfo
// {
//     StatusType type;
//     std::string id;
// };
//
// struct VersionInfo
// {
//     std::string version;
//     int num;
//     std::string latestVersion;
//     int latestVersionNum;
//     int lastCheckedDay;
//     int lastCheckedMonth;
//     int lastCheckedYear;
//     std::string platform;
// };
//
// enum class BufferType
// {
//     Replace,
//     ReplaceIndex,
//     ReplaceLines,
//     RunIndex
// };
//
// struct BufferInfo
// {
//     BufferType type;
//     std::string id;
//     int bufferIndex;
//     std::string content;
//     int line;
//     int index;
//     int lineNumber;
//
//     // replace-lines
//     int startLine;
//     int finishLine;
//     int pointLine;
//     int pointIndex;
// };
//

  find_home_path() {
    var homePath;
    var pszHome = process.env["SONIC_PI_HOME"];
    if (pszHome != null) {
      homePath = path.normalize(pszHome);
    }

    // Check for home path existence and if not, use user documents path
    if (!fs.existsSync(homePath)) {
      homePath = os.homedir();
    }

    // Final attempt at getting the folder; try to create it if possible
    if (!fs.existsSync(homePath)) {
      fs.mkdir(homePath, { recursive: false }, (err) => {
        if (err) throw err;
      });
    }
    return homePath;
  }


// Initialize the API with the sonic pi root path (the folder containing the app folder)
  init(root) {
    if (this.state == State.Created) {
      console.err("Call shutdown before init!");
      return false;
    }

    // Start again, shutdown if we fail init
    this.state = State.Invalid;
    // auto exitScope = sg::make_scope_guard([&]() {
    //     if (this.state == State::Invalid)
    //     {
    //         LOG(DBG, "Init failure, calling shutdown");
    //         Shutdown();
    //     }
    // });

    // A new Guid for each initialization
    m_guid = uuid.v4();

    if (!fs.existsSync(root)) {
        return atom.notifications.addError(`Could not find root path: ${root}`);
    }

    var homePath = this.find_home_path();

    this.m_paths.RootPath = path.normalize(root);

    if (process.platform == "win32") {
      this.m_paths.RubyPath = path.join(this.m_paths.RootPath, "app/server/native/ruby/bin/ruby.exe");
    } else {
      this.m_paths.RubyPath = path.join(this.m_paths.RootPath, "app/server/native/ruby/bin/ruby");
    }

    if (!fs.existsSync(this.m_paths.RubyPath)) {
      this.m_paths.RubyPath = "ruby";
    }

    // Create script paths
    this.m_paths.DaemonPath = path.join(this.m_paths.RootPath, "app/server/ruby/bin/dameon.rb");
    if (!fs.existsSync(this.m_paths.DaemonPath)) {
        return atom.notifications.addError(`Could not find script path: ${this.m_paths.DaemonPath}`);
    }
    // this.m_paths.PortDiscoveryPath = path.join(this.m_paths.RootPath, "app/server/ruby/bin/port-discovery.rb");
    // this.m_paths.FetchUrlPath      = path.join(this.m_paths.RootPath, "app/server/ruby/bin/fetch-url.rb");
    // this.m_paths.InitScriptPath    = path.join(this.m_paths.RootPath, "app/server/ruby/bin/init-script.rb");
    // this.m_paths.ExitScriptPath    = path.join(this.m_paths.RootPath, "app/server/ruby/bin/exit-script.rb");
    // this.m_paths.TaskRegisterPath  = path.join(this.m_paths.RootPath, "app/server/ruby/bin/task-register.rb");
    //
    // // Sanity check on script existence
    // const checkPaths = [
    //   this.m_paths.RubyServerPath,
    //   this.m_paths.PortDiscoveryPath,
    //   this.m_paths.FetchUrlPath,
    //   this.m_paths.InitScriptPath,
    //   this.m_paths.ExitScriptPath,
    //   this.m_paths.TaskRegisterPath
    // ];
    // checkPaths.forEach((path, i) => {
    //   if (!fs.existsSync(path)) {
    //       return atom.notifications.addError(`Could not find script path: ${path}`);
    //   }
    // });

    // Samples
    this.m_paths.SamplePath = path.join(this.m_paths.RootPath, "etc/samples");

    // Sonic pi home directory
    this.m_paths.UserPath = path.join(homePath, ".sonic-pi");
    var logPath = path.join(this.m_paths.UserPath, "log");

    // Make the log folder and check we can write to it.
    // This is /usr/home/.sonic-pi/log
    m_homeDirWriteable = true;
    try {
      if (!fs.existsSync(logPath)) {
        fs.mkdirSync(logPath);
        fs.writeFileSync(path.join(logPath, ".writeTest"), "test");
        fs.unlinkSync(path.join(logPath, ".writeTest"));
      }
    } catch (err) {
      atom.notifications.addWarning(`Home directory not writable: ${err.message}`);
      console.error(err);
      m_homeDirWriteable = false;
    }

    // Our log paths
    this.m_paths.ServerErrorLogPath  = path.join(logPath, "server-errors.log");
    this.m_paths.ServerOutputLogPath = path.join(logPath, "server-output.log");
    this.m_paths.ProcessLogPath      = path.join(logPath, "processes.log");
    this.m_paths.SCSynthLogPath      = path.join(logPath, "scsynth.log");
    this.m_paths.GUILogPath          = path.join(logPath, "gui.log");
    //
    // // Setup redirection of log from this app to our log file
    // // stdout into ~/.sonic-pi/log/gui.log
    // if (m_homeDirWriteable && (m_logOption == LogOption::File))
    // {
    //     m_coutbuf = std::cout.rdbuf();
    //     m_stdlog.open(m_paths.GUILogPath.string().c_str());
    //     std::cout.rdbuf(m_stdlog.rdbuf());
    // }

    // Clear out old tasks from previous sessions if they still exist
    // in addition to clearing out the logs
    const init_script = child_process.spawnSync(this.m_paths.RubyPath, [this.m_paths.InitScriptPath]);
    if (init_script.error) {
      console.log('error', init_script.error);
      return false;
    }

    console.log("Welcome to Sonic Pi");
    console.log("===================");

    if (!this.get_ports()) {
        return false;
    }
    if (!this.start_osc_server()) {
        return false;
    }
    if (!this.start_ruby_server()) {
        return false;
    }

    this.state = State.Initializing;

    console.log("Init SonicPi Succeeded...");
    return true;
  }


  start_boot_daemon() {
    console.log("Launching Sonic Pi Boot Daemon:");

    var output;

    var cmd = this.m_paths.RubyPath;
    var args = [];
    args.push(this.m_paths.DaemonPath);

    this.m_bootDaemonProcess = proc_utils.start_process(cmd, args, this.m_paths.ServerOutputLogPath, this.m_paths.ServerErrorLogPath);

    if (!m_bootDaemonProcess) {
      atom.notifications.addError("The Sonic Pi Boot Daemon could not be started!");
      console.error("Failed to start the Boot Daemon!");
      return false;
    }

    console.log("Attempting to read Boot Daemon output");

    // We need a mutex along with `output` to prevent the main thread and
    // background thread from modifying `output` at the same time (`std::string`
    // is not thread safe).
    uint8_t buffer[4096];
    auto res = m_bootDaemonProcess->read(reproc::stream::out, buffer, sizeof(buffer));

    int bytes_read = (int)res.first;
    std::error_code ec = res.second;

    if(ec || bytes_read < 0) {
      if(ec) {
        LOG(ERR, "Error reading ports via Boot Daemon STDOUT. Bytes read: "  + std::to_string(bytes_read) + " Error code: " << ec);

      } else {
        LOG(ERR, "Failed to read ports via Boot Daemon STDOUT. Bytes read: " + std::to_string(bytes_read));

    }
            return false;
    }

    std::string input_str(buffer, buffer + bytes_read);

    input_str = string_trim(input_str);
    auto daemon_stdout = string_split(input_str, " ");
    std::transform(daemon_stdout.begin(), daemon_stdout.end(), daemon_stdout.begin(), [](std::string& val) { return string_trim(val); });


    for(int i = 0 ; i < daemon_stdout.size() ; i ++) {
      LOG(INFO, "daemon_stdout: " + daemon_stdout[i]);
    }

    if(daemon_stdout.size() != 8) {
      LOG(ERR, "\nError. Was expecting 7 port numbers and a token from the Daemon Booter. Got: " + input_str + "\n");
      return false;
    }

    m_ports[SonicPiPortId::daemon] = std::stoi(daemon_stdout[0]);
    m_ports[SonicPiPortId::gui_listen_to_spider] = std::stoi(daemon_stdout[1]);
    m_ports[SonicPiPortId::gui_send_to_spider] = std::stoi(daemon_stdout[2]);
    m_ports[SonicPiPortId::scsynth] = std::stoi(daemon_stdout[3]);
    m_ports[SonicPiPortId::tau_osc_cues] = std::stoi(daemon_stdout[4]);
    m_ports[SonicPiPortId::tau] = std::stoi(daemon_stdout[5]);
    m_ports[SonicPiPortId::phx_http] = std::stoi(daemon_stdout[6]);
    m_token = std::stoi(daemon_stdout[7]);

    LOG(INFO, "Setting up OSC sender to Spider on port " << m_ports[SonicPiPortId::gui_send_to_spider]);
    m_spOscSpiderSender    = std::make_shared<OscSender>(m_ports[SonicPiPortId::gui_send_to_spider]);

    LOG(INFO, "Setting up OSC sender to Daemon on port " << m_ports[SonicPiPortId::daemon]);
    m_spOscDaemonSender = std::make_shared<OscSender>(m_ports[SonicPiPortId::daemon]);

    LOG(INFO, "Setting up OSC sender to Tau on port " << m_ports[SonicPiPortId::tau]);
    m_spOscTauSender       = std::make_shared<OscSender>(m_ports[SonicPiPortId::tau]);
    LOG(INFO, "Setting up Boot Daemon keep alive loop");
    m_bootDaemonSockPingLoopThread = std::thread([&]() {
      while(m_keep_alive.load())
      {
        LOG(DBG, "SND keep_alive");
        Message msg("/daemon/keep-alive");
        msg.pushInt32(m_token);
        m_spOscDaemonSender->sendOSC(msg);
        LOG(DBG, "SND keep_alive sent");
        std::this_thread::sleep_for(4s);
      }
      LOG(INFO, "Keep Alive Thread Loop has completed.");
    });

    m_startServerTime = timer_start();
    return true;
}

  start_ruby_server() {
    var cmd = this.m_paths.RubyPath;
    var args = [];
    args.push("--enable-frozen-string-literal");
    args.push("-E");
    args.push("utf-8");
    args.push(this.m_paths.DaemonPath);

    if (this.use_udp == true) {
        args.push("-u");
    } else {
        args.push("-t");
    }

    args.push(this.m_ports.server_listen_to_gui);
    args.push(this.m_ports.server_send_to_gui);
    args.push(this.m_ports.scsynth);
    args.push(this.m_ports.scsynth_send);
    args.push(this.m_ports.server_osc_cues);
    args.push(this.m_ports.erlang_router);
    args.push(this.m_ports.websocket);

    console.log("Launching Sonic Pi Runtime Server:");

    console.log(`Args: ${cmd} ${args.join(" ")}`);

    if (m_homeDirWriteable) {
      this.m_spRubyServer = proc_utils.start_process(cmd, args, this.m_paths.ServerOutputLogPath, this.m_paths.ServerErrorLogPath);
    } else {
      this.m_spRubyServer = proc_utils.start_process(cmd, args);
    }

    if (!this.m_spRubyServer) {
      atom.notifications.addError("The Sonic Pi Server could not be started!");
      console.error("Failed to start ruby server!");
      return false;
    }

      // // Register server pid for potential zombie clearing
      // RunProcess(std::vector<std::string>{ GetPath(SonicPiPath::RubyPath).string(), GetPath(SonicPiPath::TaskRegisterPath).string(), std::to_string(m_spRubyServer->pid().first) });
      // LOG(INFO, "Ruby server pid registered: " << m_spRubyServer->pid().first);
      //
      // m_startServerTime = timer_start();

    return true;
  }

  shutdown() {
    if (this.state == State.Created || this.state == State.Invalid || this.state == State.Initializing)
    {
        console.log("Shutdown");
        // m_spAudioProcessor.reset();
        // this.StopServerAndOsc();
        // this.RunCleanupScript();
        // if (m_coutbuf)
        // {
        //     std::cout.rdbuf(m_coutbuf); // reset to stdout before exiting
        //     m_coutbuf = nullptr;
        // }
    }
    this.state = State.Start;
  }

  get_ports() {
    const port_discovery = child_process.spawnSync(this.m_paths.RubyPath, [this.m_paths.PortDiscoveryPath]);
    if (port_discovery.error) {
      console.log('error', port_discovery.error);
      return false;
    }

    // Split
    // Trim and replace - with _ because our enum uses underscores
    var output = port_discovery.stdout.toString()
    console.log(output)
    var ports = output.replace("-", "_").split("\n");
    console.log(ports);

    var port_map = {};
    ports.forEach((item, i) => {
      if (item != "") {
        var [id, port] = item.split(": ");
        port = Number(port)
        if (Object.values(port_map).includes(port)) {
          console.log(`Duplicate: ${id}: ${port}`);
        } else {
          port_map[id] = port;
        }

      }
    });

    console.log(port_map);
    console.log("Checking Ports: ");

    var missingPort = false;
    Object.entries(port_map).forEach(([id,port]) => {
      this.m_ports[id] = port;

      var server = net.createServer(function(socket) {
        socket.write('Echo server\r\n');
        socket.pipe(socket);
      });
      server.on('error', function (e) {
        console.error(`${id}: ${port} [Not Available]`);
        missingPort = true;
        server.close();
      });
      server.on('listening', function (e) {
        server.close();
        console.log(`${id}: ${port} [OK]`);
      });

      server.listen("127.0.0.1", port);
    });

    if (missingPort) {
      console.error("Critical Error. One or more ports is not available.");
      atom.notifications.addError("One or more ports is not available. Is Sonic Pi already running? If not, please reboot your machine and try again.");
      return false;
    } else {
      console.log("All Ports OK!");
    }

    return true;
  }

  start_osc_server() {
    this.oscClient = new osc.Client("127.0.0.1", this.m_ports.server_listen_to_gui);

    this.oscServer = new osc.Server(this.m_ports.server_send_to_gui, '0.0.0.0', () => {
      console.log('OSC Server is listening');
    });
    this.oscServer.on('message', function (msg) {
      console.log(`Message: ${msg}`);
    });
    return true;
  }

  send_osc(args) {
    this.oscClient.send(...(args), () => {
      //client.close();
    });
    //return res;
  }
//}
//
// bool SonicPiAPI::WaitForServer()
// {
//     if (m_state == State::Created)
//     {
//         return true;
//     }
//
//     if (m_state != State::Initializing)
//     {
//         return false;
//     }
//
//     //QString contents;
//     LOG(INFO, "Waiting for Sonic Pi Server to boot...");
//     bool server_booted = false;
//     if (!m_homeDirWriteable)
//     {
//         // we can't monitor the logs so hope for the best!
//         std::this_thread::sleep_for(15s);
//         server_booted = true;
//     }
//     else
//     {
//         // TODO: Is this really necessary?
//         for (int i = 0; i < 30; i++)
//         {
//             auto contents = file_read(GetPath(SonicPiPath::ServerOutputLogPath));
//             if (contents.find("Sonic Pi Server successfully booted.") != std::string::npos)
//             {
//                 LOG(INFO, "Sonic Pi Server successfully booted.");
//                 server_booted = true;
//                 break;
//             }
//             else
//             {
//                 std::cout << ".";
//                 std::this_thread::sleep_for(2s);
//             }
//             server_booted = true;
//             break;
//         }
//     }
//
//     if (!server_booted)
//     {
//         MessageInfo message;
//         message.type = MessageType::StartupError;
//         message.text = "Critical error! Could not boot Sonic Pi Server.";
//
//         m_pClient->Report(message);
//         return false;
//     }
//
//     int timeout = 60;
//     LOG(INFO, "Waiting for Sonic Pi Server to respond...");
//     while (m_spOscServer->waitForServer() && timeout-- > 0)
//     {
//         std::this_thread::sleep_for(1s);
//         std::cout << ".";
//         if (m_spOscServer->isIncomingPortOpen())
//         {
//             Message msg("/ping");
//             msg.pushStr(m_guid);
//             msg.pushStr("QtClient/1/hello");
//             SendOSC(msg);
//         }
//     }
//     std::cout << std::endl;
//
//     if (!m_spOscServer->isServerStarted())
//     {
//         MessageInfo message;
//         message.type = MessageType::StartupError;
//         message.text = "Critical error! Could not connect to Sonic Pi Server.";
//
//         m_pClient->Report(message);
//         return false;
//     }
//     else
//     {
//         auto time = timer_stop(m_startServerTime);
//         LOG(INFO, "Sonic Pi Server connection established in " << time << "s");
//
//         // Create the audio processor
//         m_spAudioProcessor = std::make_shared<AudioProcessor>(m_pClient, GetPort(SonicPiPortId::scsynth));
//
//         // All good
//         m_state = State::Created;
//
//         return true;
//     }
// }

  play(code) {
      this.send('/play', m_guid, code);
  }

  stop_server() {
    /*
    * TODO: TCP
    if(m_protocol == APIProtocol::TCP){
        clientSock->close();
    }
    */

    // Ask the server to exit
    if (!m_spRubyServer) {
        console.log("Server process is not running.");
    } else {
        // Ask the server to exit
        // This happens really fast, and the process is typically gone before we get to the sleep below.
        console.log("Asking server process to exit...");
        msg = ["/exit", m_guid];
        send_osc(msg);

        // Reproc is having a hard time figuring out that the process has gone because
        // the ruby server is holding onto a socket and not cleaning it up.
        // We use a quick platform-independent check for exit instead, and just give it a second
        // for that check to succeed before doing reproc's wait/terminate/kill process which
        // will inevitably succeed too; just with a longer delay.
        // We should fix the ruby layer and remove these extra checks
        sleep(1000);

        // Quick check for it if it now gone
        if (m_spRubyServer.exitCode == null) {
          m_spRubyServer.kill("SIGTERM");
          m_spRubyServer.kill("SIGKILL");
        };
    }

    // Stop the osc server and hence the osc thread
    if (m_spOscServer)
    {
        console.log("Stopping OSC server and client...");
        oscServer.close();
        oscClient.close();
    }
}
//
// void SonicPiAPI::RunCleanupScript()
// {
//     if (fs::exists(GetPath(SonicPiPath::ExitScriptPath)))
//     {
//         // Ensure child processes are nuked if they didn't exit gracefully
//         LOG(DBG, "Executing exit script: " << GetPath(SonicPiPath::ExitScriptPath));
//         auto ret = RunProcess({ GetPath(SonicPiPath::RubyPath).string(), GetPath(SonicPiPath::ExitScriptPath).string() });
//         if (ret)
//         {
//             LOG(ERR, "Failed to call exit: " << ret.message());
//             return;
//         }
//     }
// }
//
// void SonicPiAPI::BufferNewLineAndIndent(int point_line, int point_index, int first_line, const std::string& code, const std::string& fileName, const std::string& id)
// {
//     Message msg("/buffer-newline-and-indent");
//     msg.pushStr(id);
//     msg.pushStr(fileName);
//     msg.pushStr(code);
//     msg.pushInt32(point_line);
//     msg.pushInt32(point_index);
//     msg.pushInt32(first_line);
//     SendOSC(msg);
// }
//
// (const std::string& buffer, const std::string& text)
// {
//     Message msg("/save-and-run-buffer");
//     msg.pushStr(m_guid);
//     msg.pushStr(buffer);
//     msg.pushStr(text);
//     msg.pushStr(buffer);
//     bool res = SendOSC(msg);
// }
//
// stop()
// {
//     Message msg("/stop-all-jobs");
//     msg.pushStr(m_guid);
//     SendOSC(msg);
// }
//
// uint32_t SonicPiAPI::MaxWorkspaces() const
// {
//     return 10;
// }
//
// void SonicPiAPI::LoadWorkspaces()
// {
//     for (uint32_t i = 0; i < MaxWorkspaces(); i++)
//     {
//         Message msg("/load-buffer");
//         msg.pushStr(m_guid);
//         std::string s = "workspace_" + string_number_name(i);
//         msg.pushStr(s);
//         SendOSC(msg);
//     }
// }
//
// void SonicPiAPI::SaveWorkspaces(const std::map<uint32_t, std::string>& workspaces)
// {
//     LOG(INFO, "Saving workspaces");
//
//     for (uint32_t i = 0; i < MaxWorkspaces(); i++)
//     {
//         auto itrSpace = workspaces.find(i);
//         if (itrSpace != workspaces.end())
//         {
//             Message msg("/save-buffer");
//             msg.pushStr(m_guid);
//             std::string s = "workspace_" + string_number_name(i);
//             msg.pushStr(s);
//             msg.pushStr(itrSpace->second);
//             SendOSC(msg);
//         }
//     }
//
// }
//
// bool SonicPiAPI::SaveAndRunBuffer(const std::string& name, const std::string& text)
// {
//     std::string code = text;
//     m_settings.Preprocess(code);
//
//     Message msg("/save-and-run-buffer");
//     msg.pushStr(m_guid);
//     msg.pushStr(name);
//     msg.pushStr(code);
//     msg.pushStr(name);
//     bool res = SendOSC(msg);
//     if (!res)
//     {
//         return false;
//     }
//     return true;
// }
//
// const APISettings& SonicPiAPI::GetSettings() const
// {
//     return m_settings;
// }
//
// void SonicPiAPI::SetSettings(const APISettings& settings)
// {
//     m_settings = settings;
// }

//} // namespace SonicPi
}
